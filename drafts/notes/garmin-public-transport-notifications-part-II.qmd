---
title: "Identifying prototype points for Garmin Transit Notification App"

bibliography:
 - ../../references/hci.bib
csl: ../../references/apa.csl
---

(note to self: I will add graphics to the post once I have implemented stuff)

In the last iteration of this post series on developing a Garmin transport notification application, we [discussed scenarioes and started developing high-level requirements and a few diagram](./garmin-public-transport-notification-app-part-I.qmdnotes/). I still do not know if this is _right_ and there is a lot of things to figure out. And the best way of figuring something out, in my opinion and experience, is to prototype it.

Now, I believe and teach that prototyping is not just a semi-random excursion into building _something_, but a strategic method driven by well-articulated problems that one needs to inform or identify solutions for. There is a lot of good papers on prototyping, I usually recommend Floyd's paper on _"A Systematic look at Prototyping"_ [@floyd1984systematic] and perhaps Lim et al's. paper on _"The Anatomy of Prototypes"_ [@lim2008anatomy], although it is a bit more oriented towards physical design. I will spend a bit time on some of the points from Floyd, because I will use them to analyse the scenarios and context diagram of our Garmin transit notification app to identify oppertunities for prototyping parts of the system to figure out how to proceed and prioritize in the development process.

## Prototyping as a strategic method
The most important rule for prototyping is the _economic principle of prototyping_, which states that _"the best prototype is one that, in the simplest and most efficient way, makes the possibilities and limitations of a design idea visible and measurable"_ [@lim2008anatomy, p.3]. Following this, we should carefully identify the features we need more information about and then _how_ and in what format we can create a prototype that can inform us. This includes setting criteria for evaluation and success. People often miss the material dimension. We do not need elaborate tooling or interactive examples if we need to prototype the layout of a page. That can be done with pen and paper, and evaluated with someone who knows the task the system should support; If we need to figure out if a certain part of the sytem scales, we do not need a user interface. We can just set up a benchmark prototype to identify issues related to scale. 

The second important rule is that prototypes should be _discarded after the process is completed_. Throw them out and keep the lessons learned -- do not put protypes into production!

Floyd outlines a few terms to be used when prototyping. First, the objective of the prototype. Here she defines three different objectives:

- Exploratory: Prototypes as a way of exploring a problem-solution space through multiple iterations and alternatives
- Experimental: Prototypes as a way to test a critical component through formularing an experiment
- Evolutionary: An approach to prototyping where the prototype scales into final features etc. 

I like the two first, because they contain clear criteria for when the prototype is done and discarded. Only the insights are kept. I dislike the latter as it is often unintentionally happening and when prototypes become products we often miss important procedures for quality assurance (e.g. TDD) and `the big picture' (e.g. software architecture design discussions).

The second set of terms Floyd outline are two different types of prototypes:

- Horizontal prototypes: Explore features without the deep implementation, e.g. interface, interaction, flow, protocol design, architecture
- Vertical: Explore features in how they are implemented, e.g. from user input, over submit and validation, to backend persistence

My typical example is that you can have both a horizontal and vertical prototype for buying an airplane ticket. The horizontal prototype explores the user interfaces, service design, payment etc. without ever touching the backend system. The vertical prototype examines _how_ the ticket is reserved in the system, registration, payment and confirmation etc. 

Finally, Floyd offer an stepwise approach to prototyping:

- **Functional selection**: Identify the feature the prototype should explore or inform
- **Construction**: Identify what needs to be constructed for the prototype to inform the design
- **Evaluation**: Identify the criteria on which the prototype should be evaluated (and when it is successful) 
- **Future use**: The role the prototype could play in the future of the system (early demo, training etc.)

The three first should be part of all prototyping processes. The last one should only be considered if there is a pressing need. 

## Identifying prototypes
The next step in developing out Garmin Trafic notification app, is to identify some possible points where prototypes can help inform the design and features of the system. Before we do this, lets revisit the scenario and a few of the top-level requirements:

_The user is getting ready in the morning. Their smartwatch notifies them that the bus for work is leaving in 15 minutes, so they have to walk in 5 minutes to catch it. They snoozes the notification. 4 minutes later the notification goes off again. The user decides that they is not ready yet, so they press next on the smart watch app. 10 minutes later, their Garmin smartwatch notifices them that the train is leaving in 15 minutes, so they have to walk in 5 minutes to catch it. The user accepts the notification and pack the last things in his back. 5 minutes later they leave for the train._

From the scenario and design features identified in the last post, we can destill some neccesary user-stories:

- As a user, I want to be able to select 'next' transportation option to postpone notifications until relevant.

- As a user, I want to be able to 'accept' a transportation option to indicate that I have chosen to use that connection

- As a user, I want to configure frequent destinations and a travel-window, so that I can get relevant notifications on public transit times and walking distance.

The two first user stories are derived directly from the scenario. Given that the device has a limited number of interaction options (touch / buttons), these can and should be prototyped as part of the sprint wherein the feature is implemented.

However, the last user story is a bit more open. We do not know _how_ to best support defining frequent locations and transporation windows or _where_. We do not know if doing it on the Garmin smartwatch is feasible, usable or provide the best user experience, compared to doing it in an accompanied smartphone application or in a browser. The _activity_ itself happens outside the primary use of the system. Hence, we should do a couple of _exploratory horisontal prototypes_ to test:

- Which interaction technique is best suited for the user story: touch and buttons on smartwatch, configuration pane in the Garmin Connect page where the user installs the app to the smartwatch, or on a responsive website. 

- What are the suited metaphors for defining frequent locations and in particular the travel-time window?

- And more technically, how are the user preferences persisted and transfered to the watch?

The last prototype might be a _vertical experimental prototype_ as it deals with cross-component interaction.

If we turn our attention to C4 container diagram from the last post, we can use that to identify technical prototypes for the project. 

```{dot}
//| label: fig-container
//| fig-cap: Container View Garmin GTFS Notification App.

digraph {
  compound=true
  graph [fontname="Arial", rankdir=TB, ranksep=1.0, nodesep=1.0]
  node [fontname="Arial", shape=box, margin="0.4,0.3"]
  edge [fontname="Arial"]

  1 [id=1,shape=rect, label=<<font point-size="34">Henrik</font><br /><font point-size="19">[Person]</font><br /><br /><font point-size="24">A user of the Garmin GTFS<br />notification app</font>>, style=filled, color="#052e56", fillcolor="#08427b", fontcolor="#ffffff"]
  2 [id=2,shape=rect, label=<<font point-size="34">RejsePlanen API</font><br /><font point-size="19">[Software System]</font><br /><br /><font point-size="24">GTFS data API. Provides lines,<br />stops, departuer and arrival<br />times, connections etc.</font>>, style=filled, color="#6b6b6b", fillcolor="#999999", fontcolor="#ffffff"]
  3 [id=3,shape=rect, label=<<font point-size="34">GIS Distance API</font><br /><font point-size="19">[Software System]</font><br /><br /><font point-size="24">Provides distance and walking<br />time estimates from user<br />location to nearest departure<br />point.</font>>, style=filled, color="#6b6b6b", fillcolor="#999999", fontcolor="#ffffff"]
  4 [id=4,shape=rect, label=<<font point-size="34">Garmin Connect</font><br /><font point-size="19">[Software System]</font><br /><br /><font point-size="24">Garmin smartphone application<br />for distributing smartwatch<br />applications</font>>, style=filled, color="#6b6b6b", fillcolor="#999999", fontcolor="#ffffff"]

  subgraph cluster_6 {
    margin=25
    label=<<font point-size="24"><br />Garmin App</font><br /><font point-size="19">[Software System]</font>>
    labelloc=b
    color="#444444"
    fontcolor="#444444"
    fillcolor="#444444"

    7 [id=7,shape=rect, label=<<font point-size="34">Garmin Smartwatch app</font><br /><font point-size="19">[Container: Monkey C SDK]</font><br /><br /><font point-size="24">The smartwatch application<br />that is the primary on-the-go<br />way of interacting with the<br />system.</font>>, style=filled, color="#0b4884", fillcolor="#1168bd", fontcolor="#ffffff"]
    8 [id=8,shape=rect, label=<<font point-size="34">Webapplication</font><br /><font point-size="19">[Container: JavaScript]</font><br /><br /><font point-size="24">A web application that helps<br />the user define their<br />preferences by providing<br />IF-THIS-THEN-THAT rules for<br />the garmin app.</font>>, style=filled, color="#0b4884", fillcolor="#1168bd", fontcolor="#ffffff"]
    9 [id=9,shape=cylinder, label=<<font point-size="34">Database</font><br /><font point-size="19">[Container: Garmin SDK DB API]</font><br /><br /><font point-size="24">Stores user preferences<br />(time/destination)</font>>, style=filled, color="#0b4884", fillcolor="#1168bd", fontcolor="#ffffff"]
  }

  1 -> 4 [id=14, label=<<font point-size="24">Install Garmin app on<br />smartwatch.</font>>, style="dashed", color="#707070", fontcolor="#707070"]
  4 -> 7 [id=19, label=<<font point-size="24">Transfers user<br />configuration</font>>, style="dashed", color="#707070", fontcolor="#707070"]
  7 -> 9 [id=20, label=<<font point-size="24">Store user preferences</font>>, style="dashed", color="#707070", fontcolor="#707070"]
  7 -> 1 [id=21, label=<<font point-size="24">Notifies user about next<br />possible transit</font>>, style="dashed", color="#707070", fontcolor="#707070"]
  7 -> 3 [id=22, label=<<font point-size="24">Estimates walking time and<br />distance</font>>, style="dashed", color="#707070", fontcolor="#707070"]
  1 -> 8 [id=23, label=<<font point-size="24">Create IF-THIS-THEN-THAT<br />rules</font>>, style="dashed", color="#707070", fontcolor="#707070"]
  8 -> 4 [id=25, label=<<font point-size="24">Transfer user preferences<br />to device</font>>, style="dashed", color="#707070", fontcolor="#707070"]
  8 -> 2 [id=29, label=<<font point-size="24">Get travel time info from<br />API</font>>, style="dashed", color="#707070", fontcolor="#707070"]
}
```

First, and connected to the user story and prototypes above, we need to figure out how to transfer and where to store user settings. Do we do it in the Garmin Connect app, on the smartphone or somewhere else.

Second, there we need to prototype the interaction with the RejsePlanen API to identify the best strategy (and where in the system) for querying and interacting with the GTSF data.

Both these could be _horisontal exploratory prototypes_ testing various connections and query strategies and/or _vertical prototypes_ exploring the best strategy for integrating the features into the different components.

Finally, there are likely additional prototypes needed in the beginning of the development of the application. The developer (me) do not know the tooling or SDK for developing within the Garmin ecosystem, nor does he know Monkey-C. Here it would be beneficial to construct a few smaller prototypes as a vehicle for learning the technologies required. It is a good strategy to seperate these from the actual implementation to avoid noise related to design decisions for the system in the early stages.

## Crucial prototypes to start off with
This short analysis leaves us with three crucial prototypes that needs to be developed. I will list them here following Floyd's process.

#### UI/UX: Setting location and transit window

- **Functional selection**: User interface for configuring location and transit window
- **Construction**: User interface sketches, interactive UI prototype for web, smartphone and watch
- **Evaluation**: Comparative heuristic usability evaluation and end-user evaluation for user experience.

#### API: Integrating RejsePlanen GTFS data 

- **Functional selection**: API interface between application backend and GTFS API
- **Construction**: Query code and data handling
- **Evaluation**: Optimize API calls to maximize data fetching

#### Communication: Transfer settings to the watch

- **Functional selection**: Transfer user settings to device
- **Construction**: Data format and protocol for transfering from UI to Garmin watch
- **Evaluation**: Most effecient data storage on watch

Note: We do not know what the origin interfaces will be, but will focus on designing the configuration data for the target device.

## Summary
Prototyping is an important part of the sprint structure and we will identify more things that needs prototyping as we go along. Those we have identified above will provide enough tasks for the development for the next forseeable time.

There is a parallel post to this one looking into user stories in more detail, and soon I will post something on the _actual_ development of the prototypes and application.