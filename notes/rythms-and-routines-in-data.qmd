---
title: "Rythms and Routines in Data"
code-fold: true
code-summary: "Show the code"
---


Data reflects the world and systems that generates it. A lot of the patterns that can be identified using various analytic methods are not surprising, but quite obvious if looking to the practices producing the data. In many ways, it makes more sense to talk about rythms and routines when considering patterns in data. The patterns are weak or strong signals, or residue or traces of the people and practices, and not isolated patterns only visible in the data. A lot can be revealed from observing, engaging with, participating in and reflecting on a given practice in parallel with analysing the data it produces. 

**Lets dive into some data and look at some patterns to examplify what I mean with rythms and routines in relation to data.**

## Data on electricity consumption
In Denmark anyone can download data on their electricity consumption from [El Overblik](https://eloverblik.dk/welcome). You can download data for your household meter with a resolution from year, over month and day, to hour and even every 15 minutes in some cases. We start with a dataset over my households electricity consumption since November 2017 per month. Some wrangling is required to reduce object and format the data. 

```{ojs}
// | output: all
// Loading our data file
months = FileAttachment("/public/data/el-consumption-months-all.csv").csv({typed:true}).then(raw => {
    //We want to simplify our objects and translate the values into appropriate formats.
    //We keep the date and the value
    raw = raw.filter(o => {
        var str = o["Fra_dato"].substring(6,10)
        return o["Type"] === "Tidsserie" && str != "2017"
    })
    raw = raw.map(o => {
            var d_str = o["Fra_dato"].replace(" 00:00:00", "").split("-")
            var d = new Date(d_str[2],parseInt(d_str[1])-1)
            var v = typeof o["Mængde"] == "string" ? parseInt(o["Mængde"]) : o["Mængde"]
            // We add a couple of things. The fakedate allow us to place all the values in the same year (to wrangle )
            return {date: d, kwhs: parseInt(o["Mængde"]), year: d.getFullYear(), month:d.getMonth(), fakedate: new Date(2022,d.getMonth())}
    })

    return raw.sort((a,b) => {
        return a["date"] > b["date"]
    })
})
``` 

Now that we have some data, we can start to look at some patterns. 

## Rythms in Data
```{ojs}

Plot.plot({
    width:860,
    height:400,
    marginLeft: 50,
    legend: true,
    x: {
        ticks: 20,
        grid: true,
        label: "Months",
        domain: [months[0]["date"],months[months.length-1]["date"]]
    },
    y: {
        label: "Consumption (kwhs)",
        grid: true,
        domain: [200, 550]
    },
    caption: html`Figure 1. Household electricity consumption (kilowatt hours) from 2018 to 2022`,
    marks: [
        Plot.line(months, {x: "date", y: "kwhs", stroke: "darkblue", strokeWidth: 1, curve: "natural"}),
    ]
})
``` 

Hard to see patterns at this level. What happens if we plot each year on an individual line?

```{ojs}

Plot.plot({
    width:860,
    height:400,
    marginLeft: 50,
    color: {
        type: "categorical",
        scheme: "Dark2",
        legend: true
    },
    x: {
        ticks: 12,
        grid: true,
        label: "Months",
        type: "time",
        tickFormat: "%B",
        domain: [new Date(2022,0,1),new Date(2022,11,1)]
    },
    y: {
        label: "Consumption (kwhs)",
        grid: true,
        domain: [200, 550]
    },
    caption: html`Figure 2. Household electricity consumption (kilowatt hours) with line for each year.`,
    marks: [
        Plot.line(months, {filter: d => d.year == 2018, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2, curve: "natural"}),
        Plot.line(months, {filter: d => d.year == 2019, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2, curve: "natural"}),
        Plot.line(months, {filter: d => d.year == 2020, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2, curve: "natural"}),
        Plot.line(months, {filter: d => d.year == 2021, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2, curve: "natural"}),
        Plot.line(months, {filter: d => d.year == 2022, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2, curve: "natural"})
    ]
})
``` 

By overlaying the years we notice some trends. First, all the lines move downward on the left side of the graph and upward on the right side of the graph. Second, around March and April, between May and June, and again around September and October the lines seem to follow a pattern. 

**Let's change resolution from months to days and see what we get.**


```{ojs}
// | output: all
// Loading our data file
days = FileAttachment("/public/data/el-consumption-days-all.csv").csv({typed:true}).then(raw => {
    //We want to simplify our objects and translate the values into appropriate formats.
    //We keep the date and the value
    raw = raw.filter(o => {
        var str = o["Fra_dato"].substring(6,10)
        return o["Type"] === "Tidsserie" && str != "2017"
    })

    raw = raw.map(o => {
            var d_str = o["Fra_dato"].replace(" 00:00:00", "").split("-")
            var d = new Date(d_str[2],parseInt(d_str[1])-1, d_str[0])
            var f = new Date(2022,parseInt(d_str[1])-1, d_str[0])
            var v = typeof o["Mængde"] == "string" ? parseInt(o["Mængde"]) : o["Mængde"]
            // We add a couple of things. The fakedate allow us to place all the values in the same year (to wrangle )
            return {date: d, kwhs: parseInt(o["Mængde"]), year: d.getFullYear(), month:d.getMonth(), fakedate: f}
    })

    return raw.sort((a,b) => {
        return a["date"] > b["date"]
    })
})
``` 

```{ojs}
Plot.plot({
    width:860,
    height:400,
    marginLeft: 50,
    color: {
        type: "categorical",
        scheme: "Dark2",
        legend: true
    },
    x: {
        ticks: 12,
        grid: true,
        label: "Months",
        type: "time",
        tickFormat: "%B",
        domain: [new Date(2022,0,1),new Date(2022,11,31)]
    },
    y: {
        label: "Consumption (kwhs)",
        grid: true,
        domain: [0, 40]
    },
    caption: html`Figure 3. Household electricity consumption (kilowatt hours) -- A mess`,
    marks: [
        Plot.line(days, {filter: d => d.year == 2018, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2}),
        Plot.line(days, {filter: d => d.year == 2019, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2}),
        Plot.line(days, {filter: d => d.year == 2020, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2}),
        Plot.line(days, {filter: d => d.year == 2021, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2}),
        Plot.line(days, {filter: d => d.year == 2022, x: "fakedate", y: "kwhs", stroke: "year", strokeWidth: 2})
    ]
})
```

**What a mess!** Let's see what we can do

