---
title: "Comparing Observable Plot, Vega-lite API and D3"
code-fold: true
---

I love the availability of public open data in Denmark and need a way to visualise these for multiple projects. I have a couple of (conflicting) requirements to consider when selecting a library for data visualizations.

- **Developer usability**: I do not want to wrangle both data and a library. A library need to feel usable and productive from the get go, without having to go through too much trial-and-error to get a simple experiment to work. This also require good consistent documentation. 
- **Developer investment**: I do not want to invest hours upon hours into a very idiosyncratic way of developing. There should be a clear link between output, productivity, and investment.
- **Effeciency**: I want to be able to move from idea to data to visualization fast
- **Customization**: ... with good options for tailorability
- **Transparency**: I firmly believe in transparency from visualization, through code and wrangling, to the data. It should never be too obscure or black-boxed for others to be unable to critique or learn from what I produce.
- **Visualisation usability**: It needs to produce visualizations that adhere to usability criteria from both Human-Computer Interaction and Information Visualisation out of the box.
- **Visual look**: They need to produce visualizations that look nice. I do not want to wrangle data, library, and styling.

I also have a small list of additional requirements supporting a production, collaboration, and sharing pipeline, but I have not yet formulated these. So that will be a thing for a later note.

The best way to figure out which libraries that fit my needs is to make a few examples to get a feel for the flow, constructs, documentation, and hurdles. In this note, I will explore [Observable Plot](https://github.com/observablehq/plot), [Vega-lite API](https://vega.github.io/vega-lite-api/), [vega](https://github.com/vega/vega) and [D3](https://d3js.org/).

## Line graph visualisation

### Data
I will be using population data from the [Danish Statistical Service](https://www.statistikbanken.dk/statbank5a/SelectVarVal/Define.asp?MainTable=HISB3) to generate a simple line chart. 

```{ojs}
//| output: all
data = FileAttachment("/public/data/dk-population-1901-2022.csv").csv({typed:true})
```


### Observable Plot

```{ojs}

Plot.plot({
    width:900,
    height:400,
    x: {
        ticks: 10,
        tickFormat: function(d){return ""+d},
        domain: [1900, 2025],
        grid: true
    },
    y: {
        label: "Population (in 1000s)",
        grid: true,
        domain: [2000,6000]
    },
    caption: html`Figure 1. Danish population growth from 1901 to 2022. Source: <a href="https://www.statistikbanken.dk/statbank5a/SelectVarVal/Define.asp?MainTable=HISB3" target="new">Danish statistical service</a>.`,
    marks: [
        Plot.line(data, {x: "year", y: "population"}),
    ]
})
```


### Vega Lite API
```{ojs}
import { vl } from "@vega/vega-lite-api"

vl.markLine()
    .data(data)
    .title({"text": "Figure 2: Danish population growth from 1901 to 2022.", subtitle: 'Source: https://www.statistikbanken.dk/statbank5a/SelectVarVal/Define.asp?MainTable=HISB3' }).encode(
    vl.x().fieldQ("year").scale({"domain": [1900, 2025]}),
    vl.y().fieldQ("population").title("Population (1000s)").scale({"domain": [2000, 6000]})
).width(780).height(400).config({
        axisX: {tickCount:10, formatType:"number", format:"c"},
}).render({ renderer: "svg" })
```

### Vega
```{ojs}
vega = require("@observablehq/vega")
vega({
  $schema: "https://vega.github.io/schema/vega/v5.json",
  description: "DK Population Growth 1901 - 2022",
  width: 780,
  height: 400,
  padding: 5,
  title: "Danish population growth from 1901 to 2022",
  subtitle: "Source: https://www.statistikbanken.dk/statbank5a/SelectVarVal/Define.asp?MainTable=HISB3",
  data: [{name: "DK Population 1901 - 2022", values: data}],
  axes: [
      {orient: "bottom", scale: "x", values:Array.from({length: 13}, (x, i) => 1900 + i*10), grid: true},
      {orient: "left", scale: "y", grid: true, title: "Population (in 1000s)"}
  ],
  scales: [
      {
          name: "x",
          type: "point",
          nice: "year",
          range: "width",
          domain: {data:"DK Population 1901 - 2022",field:"year"},
          domainMin: 1900
      },
      {
          name: "y",
          type: "linear",
          range: "height",
          domain: {data:"DK Population 1901 - 2022",field:"population"},
          domainMin: 2000,
          domainMax: 6000
      }

  ],
  marks: [
      {
          type: "line",
          from: {data: "DK Population 1901 - 2022"},
          encode: {
              enter: {
                  x: {scale: "x", field: "year"},
                  y: {scale: "y", field: "population"},
                  stoke: "darkblue",
                  strokeWidth: {"value": 2}
              }
          }
      }
  ]
})

```

### D3

```{ojs}
linechart = {

    const width = 900,height = 480, margin = 80, offset = margin/2

    const xScale = d3.scaleLinear().domain([1900,2030]).range([0, width-margin]);
    const yScale = d3.scaleLinear().domain([2000,6000]).range([height-margin, 0]);

    const line = d3.line()
    .x(function(d) {
        return xScale(d.year);
    })
    .y(function(d) {
        return yScale(d.population);
    })

    function gridY(){
        return d3.axisLeft(yScale).ticks(10)
    }

    function gridX(){
        return d3.axisBottom(xScale).ticks(10)
    }

    const svg = d3.create('svg')
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height])
        .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

    svg.append("g")
         .attr("transform", "translate("+offset+"," + (height-offset) + ")")
         .call(d3.axisBottom(xScale).tickFormat(function(d, i){
            return d
        }))

    svg.append("g")
        .attr("transform", "translate(" + (offset) + ", "+ offset + " )")
        .call(d3.axisLeft(yScale))
        .call(g => g.append("text")
          .attr("x", -offset)
          .attr("y", -20)
          .attr("fill", "currentColor")
          .attr("text-anchor", "start")
          .attr("font-size", "1.5em")
          .text("Population (in 1000s)"));
    
    svg.append("g")
        .attr("transform", "translate(" + (offset) + ", "+ offset + " )")
        .attr("stroke-opacity", 0.2)
        .attr("stroke-width", 0.5)
        .call(gridY().tickSize(-(width-margin))
          .tickFormat(""))

    svg.append("g")
        .attr("transform", "translate(" + (offset) + ", "+ (height-offset) + " )")
        .attr("stroke-opacity", 0.2)
        .attr("stroke-width", 0.5)
        .call(gridX().tickSize(-(height-margin))
          .tickFormat(""))
    
    svg.append("path")
        .datum(data)
        .attr("fill", "none")
        .attr("stroke", "darkblue")
        .attr("transform", "translate(" + (offset) + ", " + offset + ")")
        .attr("stroke-width", 1.5)
        .attr("d", function(d){
            return line(d)
        });

    return svg.node()
} 

html`Figure 3. Danish population growth from 1901 to 2022. Source: <a href="https://www.statistikbanken.dk/statbank5a/SelectVarVal/Define.asp?MainTable=HISB3" target="new">Danish statistical service</a>.`
```
### Summary
Following the implementations above, I have already learned a lot about the different frameworks and their feel.

#### Developer usability
D3 Plot and Vega are by far the easiest to work with of the four. D3 Plot excels in simplicity and Vega makes up for the complexity in the documentation. Vega does suffer a bit from not being able to inspect data in the output, e.g. when trying to work with [parsing](https://vega.github.io/vega/docs/data/#format) the data format. The Vega-lite API suffers a bit from its superficial documentation and lack of examples. Here I had to use the `toObject()` function to inspect the vega gramma output and then reverse engineer from common vega-lite and vega examples from the web. D3 has impressive documentation, but also a very tedious workflow. The depth of the framework means that I had to combine multiple examples to make sure that I used the correct features (yeah, no, I'm not reading the documentation as the entry point).

In many ways, vega-lite API and vega are two different ways to produce the same output (quite literally). Here I favor vega-lite API as my approach.

#### Developer investment
D3 Plot requires the least investment in my experience. The vega-lite API is a bit more, but that is mainly due to the lack of examples. Vega (and vega-lite) require significant investment in getting used to the declarative gramma. D3 will require a significant investment in terms of understanding _how it works_. It feels like D3 suffers a bit from an ideomatic code style populated through the many examples by the author. There are a lot of small steps that are combined through its almost-declarative-dot notation.

I have a few open questions regarding the vega family regarding customizability that make me less reluctant to do the investment. D3 seems worthwhile the time if I had to do more complex visualizations, but the link between Observable Plot and D3 means that there is a nice transition between making something simple in Observable Plot to explore an idea and then moving to D3 for the crazy stuff. This might also be inherent in vega, as you can do simple stuff. I am just a bit unsure _of how vega deals with more custom and complex visualizations_.

#### Efficiency
Comparing the four on efficiency with a simple line chart is not a fair comparison. Still, Observable Plot wins hands down. Next is Vega-lite API, and then Vega. D3 is just _work_ to get the result I want. 

#### Customization
This is the inverse of _effeciency_. D3 not only have a lot of options (every option it feels like), there area also so many examples showcasing the possibilities. Vega also have a lot of options for customizability, but I kept hitting some issues when wanting to define custom ranges and ticks, so I remain a bit unsure here. Observable Plot and Vega-lite API seem to offer customization in terms of styling, but very little oppertunities for moving outside the particular visualization type. 

#### Transparency
With Observable Plot and the Vega family, it is somewhat obvious what happens. D3 is another story. With D3 you need to know D3 to see what happens. The declarative nature of the Vega family makes it a bit difficult to use stdout and inspection to see what happens in the process. For instance, I could not find the `subtitle` in the vega visualization, and because vega is a canvas based it is impossible to find it by inspecting the DOM. I dislike any framework that integrates wrangling and data work as a pattern because it obscures for a viewer how one moves from the data to the visualization. However, that is more of a principle for the process than something that is enforced in the frameworks. 

#### Visualisation usability
In the simple line graph example, all the frameworks produce usable and readable graphs without the need to address particular issues. Observable Plot does make it difficult to read the axis due to a small font size. This can be changed through CSS, but will likely be a fiddly operation. [Why not have a font size configuration option?](https://talk.observablehq.com/t/label-font-size/2273/3). This might make me use Vega-lite for simple visualizations. 

#### Visual look
Observable Plot (and D3 when spending time styling it) looks amazing (aside from the font issue). I dislike the label positions and font with the Vega graphs, but that can be solved using styling. And I guess when embedding the visualizations somewhere, one wants the title and labels to fit the parent style. I know a lot can be done with [vega-embed](https://github.com/vega/vega-embed), but it seems silly to add a library for publishing the visualization when I am already doing so in this notebook format.


# Conclusion
- **Output**: Working with SVG and the DOM (over canvas) seems like a stronger strategy for production, manipulation, and customization. I can inspect everything in the DOM and use my knowledge from other front-end libraries and flows to learn and work with D3.
- **Visuals**: I immediately liked Observable Plot more than the Vega visualizations. I might even do an Observable Plot first and if needed make a D3 version and style it like the Observable Plot (with better font sizes).
- **Inspectability**: It _feels_ like I can solve issues faster because I can combine great documentation with simple techniques for inspecting the DOM, data, functions, etc.
- **Familial resemblance**: The link between Observable Plot and D3 allows me to transition nicely from simple to complex. This might also be the case with the vega family, but my experience with a few issues does not make me confident in this. 

In my next note, I will examine how to add interactivity to visualizations using the frameworks.
