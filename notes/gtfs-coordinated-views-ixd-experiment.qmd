---
    title: "IxD Experiments with coordinated views and GTFS data"
---

I have a bunch of small ideas based on [GTFS data](https://gtfs.org/) and one of the things they have in common is that I want to combine Map and UI interaction. In this small experiment I wanted to figure out how to coordinate views between a map view and traditional web-components.

## Experiment 1: Coordinated views between map route and range slider
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />

<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>

<script src="/js/leaflet.geometryutil.js"></script>
<div id="map" style="width:100%; height:600px;"></div>
<div id="linecontainer" style="width:100%; height:100px;margin:auto;text-align: center;">
<input type="range" min="0" max="100" value="0" id="line" style="margin-top:20px;width:600px;" autocomplete="off">
</div>


<script type="text/javascript">
;(function(){
    let init = async () => {
        const map = L.map('map').setView([56.15, 10.2], 12);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        map.dragging.disable();
        map.touchZoom.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
        if (map.tap) map.tap.disable();
        document.getElementById('map').style.cursor = 'default';

        const line = document.querySelector("#line")
        const response = await fetch('/public/data/281_23982_3_12_3142.geojson')
        const json = await response.json()

        const points = json.features[0].properties.latlngdistance

        const pline = new L.Polyline(points, {
            color: 'blue',
            weight: 8,
            opacity: 0.5,
            smoothFactor: 1
        });

        pline.addTo(map);
        map.fitBounds(pline.getBounds())

        const marker = L.circleMarker(points[0], { draggable: 'true', fillOpacity: 1, color:"darkblue", fillColor: "blue", radius:8 }).addTo(map)

        pline.on("click", function (e) {
            let f = L.GeometryUtil.locateOnLine(map, pline, e.latlng)
            marker.setLatLng(e.latlng)
            setLineValue(f)
        })

        marker.on("mousedown", function (e) {
            map.dragging.disable()
            map.on("mousemove", track)
        })

        map.on("mouseup", function (e) {
            map.dragging.enable()
            map.off("mousemove", track)
        })

        line.oninput = function (e) {
            let p = L.GeometryUtil.interpolateOnLine(map, pline, this.value / 100)
            marker.setLatLng(p.latLng)
        }

        function track(e) {
            let p = pline.closestLayerPoint(map.latLngToLayerPoint(e.latlng))
            marker.setLatLng(map.layerPointToLatLng(p))

            let f = L.GeometryUtil.locateOnLine(map, pline, e.latlng)
            setLineValue(f)
        }

        function setLineValue(factor) {
            line.value = factor * 100
        }
    }

    init()
})()
    

</script>

## Experiment II: Coordinated view between map and list of bus stops

<style>
        #map2 {
            width: 100%;
            height: 600px;
        }

        #list {
            margin: auto;
            height: 400px;
            margin-top: 20px;
            width: 800px;
            overflow: scroll;
            border-bottom: 1px solid #666;
        }

        table {
            margin: auto;
            width: 800px;
            font-family: Arial, Helvetica, sans-serif;
            cursor: pointer;
        }

        table,
        th,
        td {
            border: 1px solid #666;
            border-collapse: collapse;
            padding: 4px;
        }

        th {
            background: #666;
            position: sticky;
            top: 0;
            color: white;
        }

        table tr>td:last-of-type {
            text-align: center;
        }

        table tr.focus {
            background-color: lightgray;
        }
    </style>
<div id="map2">
</div>
<div id="list">
<table>
<tbody>
<tr>
<th>Stop</th>
<th>Arrival time</th>
</tr>
</tbody>
</table>
</div>


<script type="text/javascript">
;(function(){
    let init = async () => {
        const map = L.map('map2').setView([56.15, 10.2], 1);
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        //Locking interaction with map
        map.dragging.disable();
        map.touchZoom.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
        if (map.tap) map.tap.disable();
        document.getElementById('map2').style.cursor = 'default';

        const table = document.querySelector("#list table")

        table.addEventListener("mouseover", tableOver)

        const response = await fetch('/public/data/281_23982_3_12_111718624.geojson')
        const json = await response.json()

        const points = json.features[0].properties.latlngs
        const stops = json.features[0].properties.stops

        const pline = new L.Polyline(points, {
            color: 'blue',
            weight: 4,
            opacity: 0.5,
            smoothFactor: 1
        });

        pline.addTo(map);
        map.fitBounds(pline.getBounds())

        for (i in stops) {
            let stop = stops[i]
            let row = table.insertRow(-1)
            row.dataset.lat = stop.lat
            row.dataset.lng = stop.lng
            row.id = "s" + stop.stop_id
            let c0 = row.insertCell(0)
            let c1 = row.insertCell(1)
            c0.innerHTML = stop.name
            c1.innerHTML = stop.arrival
            drawstop(stop.lat, stop.lng, pline, map)
        }

        const marker = L.marker(points[0]).addTo(map)
        let icon = document.querySelector("#map2 img.leaflet-marker-icon")
        icon.draggable = false;

        function tableOver(evt) {
            let t = evt.target.nodeName == "TD" ? evt.target.parentNode : evt.target

            if (t.nodeName == "TH" || t.nodeName == "TABLE") {
                return
            }

            let focus = document.querySelector("table tr.focus")

            if (focus) {
                focus.classList = ""
            }
            t.classList = "focus"

            let latlng = L.latLng([t.dataset.lat, t.dataset.lng])
            marker.setLatLng(latlng)
        }

        pline.on("click", function (e) {
            marker.setLatLng(e.latlng)

            let p = pline.closestLayerPoint(map.latLngToLayerPoint(e.latlng))
            let closestStopId = findClosestStopID(p, stops, map)
            if (closestStopId != -1) {
                focusStopInTable(closestStopId)
            }
        })

        marker.on("mousedown", function (e) {
            map.dragging.disable()
            map.on("mousemove", track)
        })

        map.on("mouseup", function (e) {
            map.dragging.enable()
            map.off("mousemove", track)
        })

        function track(e) {
            let p = pline.closestLayerPoint(map.latLngToLayerPoint(e.latlng))
            marker.setLatLng(map.layerPointToLatLng(p));

            let closestStopId = findClosestStopID(p, stops, map)
            if (closestStopId != -1) {
                focusStopInTable(closestStopId)
            }
        }

        function drawstop(lat, lng, polyline, map) {
            L.circle([parseFloat(lat), parseFloat(lng)], { color: "darkblue", radius: 3, fillColor: "darkblue" }).addTo(map)
        }

        function findClosestStopID(point, stops, map) {
            let lowestDistance = 1000
            let closestStopId = -1

            //this can be optimized
            //either by maintaining a closestStop index for searching on move
            //or with a binary search
            //not an issue for the demo, just not ideal
            for (i in stops) {
                s = stops[i]
                let distance = map.latLngToLayerPoint(L.latLng([s.lat, s.lng])).distanceTo(point)
                if (distance < lowestDistance) {
                    closestStopId = s.stop_id
                    lowestDistance = distance
                }
            }

            return closestStopId
        }

        function focusStopInTable(stopID) {
            let focus = document.querySelector("table tr.focus")

            if (focus) {
                focus.classList = ""
            }

            let t = document.querySelector("table tr#s" + stopID)
            t.classList = "focus"
            t.scrollIntoView({ block: "center" })
        }

    }

    init()
})()
    
</script>


## Details

I downloaded the Danish GTFS data from [Rejseplanen](https://www.rejseplanen.info/labs/GTFS.zip). [I wrangled the GTFS data into a seperate file](https://github.com/henrikkorsgaard/GTFS-wrangler/blob/main/parse-gtfs-trip.py) for the transit route I'm interested in (Midttrafik).

I use [Leaflet](https://leafletjs.com/) and [Leaflet.GeometryUtil](https://github.com/makinacorpus/Leaflet.GeometryUtil) to render the route as a polyline and add the interactive elements. 

