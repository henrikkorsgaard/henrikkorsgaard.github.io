<!doctype html>
<html lang="en">
    <head>
        <link
            rel="stylesheet"
            type="text/css"
            href="https://cdn.jsdelivr.net/gh/bitmaks/cm-web-fonts@latest/fonts.css"
        />
        <link rel="stylesheet" type="text/css" href="../style/main.css" />

        <title>Instrumental Data Interaction - Henrik Korsgaard</title>
    </head>

    <body>
        <menu>
            <a href="../index.html">
                <img src="../media/images/henrik-transparent.png" />
            </a>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../about.html">About</a></li>
                <li class="here"><a href="../notes.html">Notes</a></li>
                <li><a href="../projects.html">Projects</a></li>
                <li><a href="../research.html">Research</a></li>
            </ul>
            <footer>
                <a href="mailto:korsgaard@protonmail.com">Email</a>
                <a href="https://github.com/henrikkorsgaard">GitHub</a>
                <a href="https://linkedin.com/in/henrik-korsgaard-77a0831b">LinkedIn</a>
            </footer>
        </menu>
        <page>
            <content>
                <h1>Instrumental Data Interaction</h1>

                <p class="meta">Status: Early draft</p>

                <p>I am interested in how to support people in interacting with data. Millions do it already, from querying databases, doing complex analysis in computational notebooks, working with data in spreadsheets, and interacting with information visualisations to understand a phenomena or relations through data. But in the age of the data deluge, the tools have a hard time keeping up and cognitive overload is an ever present challenge. I think we can create better tools for interacting with data, and I think there are some strong ideas from human-computer interaction and interaction design that can guide us.</p>

                <p>In this post I explore the merits of thinking about the tools we use to interact with data as an <em>instrument</em>, based on ideas from <em>instrumental interaction</em> (Beaudouin-Lafon, 2000) and <em>activity theory</em> (Kaptelinin, 1996). As tool builders, this perspective allow us to examine the tools and how we use them, as well as exploring how we can <em>improve</em> the tool with a focus on <em>what the tool can do</em>, the goal and quality of interaction. Building better tools for interacting with data would also make the vast amounts of available data accessible to a larger audience and groups.</p>

                <p>In instrumental interaction, interface elements (e.g. a colorpicker, a scrollbar, cropping tool, text-highlighting) are tools that we use to manipulate domain objects (data, documents, images etc.) through interaction. This view is from <em>activity theory</em>, where <em>use</em> is conceptualized as a <em>subject</em> using an <em>instrument</em> on a <em>object</em> towards realizing a <em>goal</em>. This could be someone using a SQL editor to query a library database with the goal of getting information on e.g most popular books based on loan data; it could be someone using a visualization library or diagrams in Excel to create a visualization; or it could be someone exploring their energy consumption through an information visualization. In all cases, instrumental interaction offer a framing for analyzing the tool within the context of an activity for the purpose of improving the tool.</p>

                <h2>SQL and instrumental interaction with data</h2>

                <p>One of the most common and fundamental ways to interact with data, is through using the <strong>S</strong>tructured <strong>Q</strong>uery <strong>L</strong>anguage (SQL). Together with the relational database, it was developed to help "the non-professional user into effective communication with a formatted database" (Chamberlin & Boyce, 1974) and "to put end users into direct touch with the information stored in computers" (Codd, 2007). SQL was considered an ideal way for non-programmers to access and query data. It was developed with an onset in English (Structured English Query Language -- SEQUEL) and a declarative approach to data querying. SQL turned out to be hugely successful and is one of the most commonly used technologies today. However, the idea that the casual user would use SQL to interact with databases on a frequent basis have not come true (yet). I'm not saying that SQL is the ideal tool for casual users, but if we could improve the tool to cater more to casual and non-technical users (e.g. designers, journalists, citizens), we can make the vast amount of data in SQL databases accessible to a significantly larger audience.</p>

                <h3>SQL as a tool</h3>

                <p><em>Note: The original version of this note contained an interactive SQL shell demo. The interactive elements have been removed during migration.</em></p>

                <p>In the original interactive example, you could use SQL as an <em>instrument</em> for interacting with a publications database. When we have to interact with an unfamiliar and undocumented database, we try to use the instrument to poke around to explore and discover how the data is organized and how to query for the information we need. This often involves multiple steps of trial-and-error to identify appropriate tables, their fields, relations and data:</p>

                <pre><code>SELECT name FROM sqlite_master;

SELECT * FROM authors LIMIT 5;

SELECT * FROM sqlite_master WHERE name='authors';</code></pre>

                <p>And you can do more complex stuff like querying multiple tables for specific results:</p>

                <pre><code>SELECT publications.title, authors.first, authors.last, publications.year
FROM publications
INNER JOIN authorship ON publications.wid=authorship.wid
INNER JOIN authors ON authorship.aid=authors.aid
WHERE authors.last='Dewey';</code></pre>

                <h2>Improving our tool</h2>

                <p>That is neat, but there are a couple of problems and/or improvements we can introduce to make the tool more <em>usable</em>. The first one is with the structure and syntax of the query itself. For experienced users that are familiar with the data model they are interacting with, it is trivial to write <code>SELECT title FROM publications;</code>. They know that there is a table called <code>publications</code> and that it contains a column with <code>title</code>. But for novice SQL users or experienced users interacting with a new database, the <code>SELECT</code> first approach does not help us before we know where we select <code>FROM</code> (using <code>SELECT *</code> as a probing strategy can help). There are a couple of interaction design ideas we can apply to solve this issue. First, for novice users, we can add something as simple as autocomplete. We know the abstract syntax tree for SQL, so it is trivial to provide users with hints to both keywords and errors.</p>

                <p>There is another small problem. Early research on the usability of different query languages by Reisner (1981) shows that some users perform poorly due to the design choice of starting queries with <code>SELECT</code> instead of allowing <code>FROM</code> first as well. Beginning with <code>SELECT</code> or <code>FROM</code> represent two fundamental query writing strategies. The former is the <em>translation strategy</em> where the user is invited to look for appropriate terms and search through trial and error (or find the data model described elsewhere). The latter is the <em>operations-on-tables</em> where the users indicate where they want to search before they search (operate). The operations-on-tables strategy is closer to the idea of instrumental interaction, than the <em>translation strategy</em> which focus more on semantic understanding. So it seems silly that we require the users to remember what they want to select before they know where from. Let's just address the issue by improving our tool so that valid SQL queries can start with <code>FROM</code> as well.</p>

                <p>There is another significant improvement we can make that combines the autocomplete and utilizes allowing queries to start with <code>FROM</code>. In many cases we know something about <em>what</em> the user can query. We likely have a finite number of tables that can go into our autocomplete feature, and once the user have shown intent with <code>FROM</code> we can also suggest columns. Putting <code>FROM</code> in front makes the autocomplete flow easier to implement, because we can narrow the suggestions based on the table selection and not the column selection.</p>

                <h2>Summary: Playing language games</h2>

                <p>Considering SQL as an instrument for interacting with data allows us to consider multiple ways we can improve the tool without ever having to change the domain object, the database. Doing so could potentially allow us to make SQL accessible to more casual non-technical users and thereby make a vast amount of data accessible as well.</p>

                <p>While we are fiddling with the SQL language, why not introduce localization? If our future users are casual users and we do not expect them to write SQL without help, why do we expect them to use English? I know that SQL is derived from Structured English Query Language (SEQUEL), but when people use it across the globe and within a broad range of domains, I don't see why we cannot offer localization or customized queries to increase accessibility and semantic intuition. And when the database, table and column names are already in local languages, why force people to mix and match when they try to translate their question to a query? If Danish journalists think "hent en liste over alle folketingets medlemmer, der stemte for lovforslag L87" (fetch me a list of all the members of parliament who voted for bill L87), why not make <code>HENT</code> synonymous with <code>SELECT</code>? That would be trivial.</p>

                <p>Similarly, and with more recent research into both Large Language Models and Natural Language Interfaces for Databases, our tool could be improved with both domain specific language features and/or a database specific LLM that supported queries based on natural language.</p>

                <p>There are other improvements to consider as well. Combining writing queries with other types of feedback, e.g. tabular views, visualizations and tabular views to support more complex queries like joins and group by. This is something I will investigate in a later post.</p>

                <p>Finally, when we 'detach' SQL from the database through the idea of SQL as an instrument, we can also explore multimodal interaction where our SQL tool can be used to interact with other data sources (APIs, tables, structured data etc.) and we can develop other tools that can interact with our database as well. This multi-multi scenario where users can use familiar tools with unfamiliar data or people can collaborate without being forced to use the same tool (tool asymmetry) is key in supporting collaboration across disciplines, e.g. in open data projects.</p>

                <p><a href="../notes.html">&larr; Back to Notes</a></p>
            </content>
        </page>
    </body>
</html>
